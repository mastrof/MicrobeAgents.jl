var documenterSearchIndex = {"docs":
[{"location":"validation/run_distribution/","page":"Run-length distribution","title":"Run-length distribution","text":"EditURL = \"../../../examples/Validation/run_distribution.jl\"","category":"page"},{"location":"validation/run_distribution/#Run-length-distribution","page":"Run-length distribution","title":"Run-length distribution","text":"","category":"section"},{"location":"validation/run_distribution/","page":"Run-length distribution","title":"Run-length distribution","text":"In a random walk where the tumbling events occur as Poissonian events, the resulting distribution of run lengths should be exponentially distributed, with the average run length satisfying tau = 1nu where nu is the average unbiased turn rate of the bacteria.","category":"page"},{"location":"validation/run_distribution/","page":"Run-length distribution","title":"Run-length distribution","text":"Since we don't work with continuous event-based simulations, the integration timestep plays an important role in the resulting distribution. If the timestep is too large compared to the typical run lengths, the resulting distibution will be affected. But if the timestep is too small, the simulations will be too expensive. In most scenarios, a timestep Delta t sim tau10 is typically the largest value with which the correct run length distribution can be properly sampled.","category":"page"},{"location":"validation/run_distribution/","page":"Run-length distribution","title":"Run-length distribution","text":"using MicrobeAgents\n\nL = 1000\nspace = ContinuousSpace((L,L,L))\ndt = 0.1 # s\nmodel = StandardABM(Microbe{3}, space, dt)\n\nruntime_expected = 2.0 # s\nunbiased_turn_rate = 1 / runtime_expected # Hz\nn = 500\nfor i in 1:n\n    add_agent!(model; turn_rate=unbiased_turn_rate)\nend\n\nnsteps = 10000\nadata = [velocity]\nadf, = run!(model, nsteps; adata)","category":"page"},{"location":"validation/run_distribution/","page":"Run-length distribution","title":"Run-length distribution","text":"To verify that we sample the expected distribution, we will first estimate the run lengths in our simulation with Analysis.detect_turns! and Analysis.run_durations, and then we will fit the resulting distribution with an Exponential distribution from Distributions.jl. We expect the fitted distribution to match our histogram and return a timescale tau close to the value of runtime_expected.","category":"page"},{"location":"validation/run_distribution/","page":"Run-length distribution","title":"Run-length distribution","text":"using Distributions\nAnalysis.detect_turns!(adf)\nrun_lengths = vcat(Analysis.run_durations(adf)...) .* dt\nestimated_pdf = fit(Exponential, run_lengths)\nτ = scale(estimated_pdf)\n\nusing Plots\nhistogram(run_lengths; bins=dt/2:2dt:5τ, normalize=:pdf,\n    lab=\"Simulation; τ = $(runtime_expected) s\", lw=0)\nplot!(dt:dt:5τ, t -> pdf(estimated_pdf, t-dt); lw=2,\n    lab=\"exp(-t/τ)/τ; τ = $(round(τ;digits=3)) s\")\nplot!(xlab=\"Δt (s)\", ylab=\"P(Δt)\")","category":"page"},{"location":"validation/velocity_autocorrelations/","page":"Velocity autocorrelation functions","title":"Velocity autocorrelation functions","text":"EditURL = \"../../../examples/Validation/velocity_autocorrelations.jl\"","category":"page"},{"location":"validation/velocity_autocorrelations/#Velocity-autocorrelation-functions","page":"Velocity autocorrelation functions","title":"Velocity autocorrelation functions","text":"","category":"section"},{"location":"validation/velocity_autocorrelations/","page":"Velocity autocorrelation functions","title":"Velocity autocorrelation functions","text":"Orientational correlations in the microbe's motion can be probed through velocity autocorrelation functions. Each motility pattern is characterized by a specific form of the velocity autocorrelation function, which have been analytically evaluated by Taktikos et al (PLoS ONE 2012). We will compare the velocity autocorrelation functions of run-tumble, run-reverse and run-reverse-flick motility, in the absence of rotational diffusion, to the analytical calculations:","category":"page"},{"location":"validation/velocity_autocorrelations/","page":"Velocity autocorrelation functions","title":"Velocity autocorrelation functions","text":"phi(t) = begincases\n    exp(-ttau)  textrun-tumble \n    exp(-2ttau)  textrun-reverse \n    (1 - t2tau)exp(-ttau)  textrun-reverse-flick\nendcases","category":"page"},{"location":"validation/velocity_autocorrelations/","page":"Velocity autocorrelation functions","title":"Velocity autocorrelation functions","text":"using MicrobeAgents\nusing Plots\n\nU = 30.0 # μm/s\nτ_run = 1.0 # s\nturn_rate = 1 / τ_run # 1/s\nΔt = 0.01 # s\nL = 1e4 # μm\nspace = ContinuousSpace((L,L,L))\n\nmodel = StandardABM(Microbe{3}, space, Δt; container=Vector)\nn = 200\nfor Mot in (RunTumble, RunReverse, RunReverseFlick), i in 1:n\n    if Mot == RunTumble\n        motility = RunTumble(τ_run, [U], 0.0)\n    else\n        motility = Mot(τ_run, [U], τ_run, [U])\n    end\n    add_agent!(model; motility)\nend\n# keep track of ids of each motile strategy\nids_runtumble = 1:n\nids_runreverse = (1:n) .+ n\nids_runrevflick = (1:n) .+ 2n\n\nnsteps = round(Int, 100τ_run / Δt)\nadata = [direction]\nadf, = run!(model, nsteps; adata)\n\n# separate the dataframes by motile strategy\nadf_runtumble = filter(:id => id -> id in ids_runtumble, adf; view=true)\nadf_runrev = filter(:id => id -> id in ids_runreverse, adf; view=true)\nadf_runrevflick = filter(:id => id -> id in ids_runrevflick, adf; view=true)\nadfs = [adf_runtumble, adf_runrev, adf_runrevflick]\n\n# evaluate the autocorrelation functions\nusing StatsBase: mean\nt = range(0, (nsteps-1)*Δt; step=Δt)\nΦ = hcat([mean(Analysis.acf(a, :direction; normalize=true)) for a in adfs]...)\n\n# from Taktikos et al.\nΦ_theoretical = hcat([\n    exp.(-t ./ τ_run),\n    exp.(-t ./ (τ_run / 2)),\n    (1 .- t ./ (2τ_run)) .* exp.(-t ./ τ_run),\n]...)\n\nplot(\n    xlims=(0,6τ_run), ylims=(-0.1, 1.05),\n    xlab=\"Δt / τ\",\n    ylab=\"velocity autocorrelation\",\n)\nplot!(t, Φ_theoretical, lw=2, lc=[1 2 3],\n    label=[\"Run-Tumble\" \"Run-Reverse\" \"Run-Reverse-Flick\"]\n)\n# show simulation values only at selected lags for better visualization\nlags = range(0, length(t)-1; step=20)\nscatter!(t[lags.+1], Φ[lags.+1,:], m=:x, mc=[1 2 3], msw=2, label=false)\nhline!([0.0], lw=0.8, ls=:dash, lc=:black, lab=false)","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"EditURL = \"../../../../examples/RandomWalks/1_randomwalk1D.jl\"","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/#1D-Random-walk","page":"1D Random walk","title":"1D Random walk","text":"","category":"section"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"Here we simulate a population of one-dimensional random walkers.","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"First we shall set up the model: we need to define the microbe type, the space and the integration timestep.","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"For the microbe type, we will choose the base type Microbe{1}, where parameter 1 refers to the number of dimensions in which the microbe can move.","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"For the space, we need to set the domain size and whether it is periodic or not. We will use a periodic box with an extent of 1000 μm; if unspecified, ContinuousSpace will default to periodic=true.","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"For the integration timestep, we choose a value of 0.1 s.","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"Remember that lengths are always assumed to be in units of microns, times in seconds.","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"using MicrobeAgents\n\nL = 1000 # space size in μm\nspace = ContinuousSpace((L,))\ndt = 0.1 # integration timestep in s\nmodel = StandardABM(Microbe{1}, space, dt)","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"Now that the model is initialized, we will add 10 microbes.","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"With the first (optional) argument to add_agent!, we can define the starting position of the microbe. For convenience, we will initialize all of them from position (0,).","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"Moreover, it's always required to specify the motility of the microbes via the keyword argument motility. For example, RunTumble needs as inputs the average duration of runs and the distribution of run speeds. Passing a one-element vector [U] means that all runs will have the same velocity U. We could have also specified the average duration of tumbles (equal to reversals in 1 dimension) via an optional 3rd argument (try it! e.g. 0.5); when unspecified, the tumbles are taken to be instantaneous.","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"n = 10 # number of microbes to add\nτ_run = 1.0 # average run duration in s\nU = 30.0 # swimming speed in μm/s\nmotility = RunTumble(τ_run, [U], 0.5)\nforeach(_ -> add_agent!((0,), model; motility), 1:n)","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"We can now run the simulation. We just need to define how many timesteps we want to simulate and what kind of data we want to store during the simulation. In this simulation, we only want to collect the microbe positions at each timestep; we then set the adata vector (agent data) to collect the position of the microbes.","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"The run! function will return a dataframe for the agent data (adf) and one for the model data (mdf) collected during the simulation. Here we are only collecting agent data and no model data.","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"nsteps = 600\nadata = [position]\nadf, _ = run!(model, nsteps; adata);\nnothing #hide","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"The simulation is done. We now want to visualize our results. One last thing we need to is to \"unfold\" the trajectories of our microbes. In fact, since we used a periodic domain, if we just plotted the trajectories we would see them crossing between the two sides of the box, which is not what we want.","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"With the unfolding, the trajectories are expanded as if they were simulated in an infinite system.","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"The unfold! function and other useful post-processing functions can be accessed through the Analysis submodule of MicrobeAgents.jl. unfold! operates directly on the agent dataframe adf and generates a new column :position_unfold from the raw :position column. After the unfolding, we extract the individual trajectories in the form of a matrix with adf_to_matrix, where each trajectory will be stored as a column. This will be convenient for plotting.","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"Analysis.unfold!(adf, model)\ntraj = Analysis.adf_to_matrix(adf, :position_unfold)\nx = first.(traj)\nt = axes(x,1) .* dt\n\nusing Plots\nplot(t, x, leg=false, xlab=\"time\", ylab=\"displacement\")","category":"page"},{"location":"examples/Chemotaxis/2_celani_gauss2D/","page":"Noisy chemotaxis towards Gaussian source","title":"Noisy chemotaxis towards Gaussian source","text":"EditURL = \"../../../../examples/Chemotaxis/2_celani_gauss2D.jl\"","category":"page"},{"location":"examples/Chemotaxis/2_celani_gauss2D/#Noisy-chemotaxis-towards-Gaussian-source","page":"Noisy chemotaxis towards Gaussian source","title":"Noisy chemotaxis towards Gaussian source","text":"","category":"section"},{"location":"examples/Chemotaxis/2_celani_gauss2D/","page":"Noisy chemotaxis towards Gaussian source","title":"Noisy chemotaxis towards Gaussian source","text":"In this example we set up a static Gaussian source and observe the chemotactic behavior of the Celani model, in the presence of sensing noise (via the chemotactic_precision). Playing with the chemotactic_precision, it can be seen that the clustering of bacteria at the source becomes stronger with decreasing noise (decreasing chemotactic precision).","category":"page"},{"location":"examples/Chemotaxis/2_celani_gauss2D/","page":"Noisy chemotaxis towards Gaussian source","title":"Noisy chemotaxis towards Gaussian source","text":"using MicrobeAgents\nusing Plots\n\nfunction concentration_field(pos, model)\n    C = model.C\n    σ = model.σ\n    p₀ = model.p₀\n    concentration_field(pos, p₀, C, σ)\nend\nconcentration_field(pos, p₀, C, σ) = C * exp(-sum(abs2.(pos.-p₀))/(2*σ^2))\n\ntimestep = 0.1 # s\nextent = ntuple(_ -> 1000.0, 2) # μm\nspace = ContinuousSpace(extent; periodic=false)\np₀ = extent./2 # μm\nC = 20.0 # μM\nσ = 100.0 # μm\nproperties = Dict(\n    :chemoattractant => GenericChemoattractant{2,Float64}(; concentration_field),\n    :C => C,\n    :σ => σ,\n    :p₀ => p₀,\n)\n\nmodel = StandardABM(Celani{2,2}, space, timestep; properties)\nmotility = RunTumble(0.67, [30.0], 0.1)\n\nfor _ in 1:300\n    add_agent!(model; motility,\n        chemotactic_precision=6.0, rotational_diffusivity=0.1\n    )\nend\n\nnsteps = 1500\nadata = [position, bias]\nadf, = run!(model, nsteps; adata)\n\ntraj = Analysis.adf_to_matrix(adf, :position)\nxmesh = range(0, first(spacesize(model)); length=100)\nymesh = range(0, last(spacesize(model)); length=100)\nc = [concentration_field(p, p₀, C, σ) for p in Iterators.product(xmesh, ymesh)]\nheatmap(xmesh, ymesh, c', cbar=false, ratio=1, c=:bone, axis=false)\nx = getindex.(traj,1)[end-300:2:end, :]\ny = getindex.(traj,2)[end-300:2:end, :]\na = axes(x,1) ./ size(x,1)\nplot!(x, y,\n    lab=false, lims=(0,1000), lw=a.^2, alpha=a,\n)","category":"page"},{"location":"randomwalks/#Random-walks","page":"Random walks","title":"Random walks","text":"","category":"section"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"Generating random walks with MicrobeAgents.jl is super-easy, and the walk properties can be fine-tuned to match all sorts of needs.","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"By default, MicrobeAgents.jl produces random walks composed of runs at constant speed and arbitrary reorientations where the waiting times between such reorientations are i.i.d. random variables. In the absence of chemotaxis (or other behavioral responses that affect microbe motility), the generated random walks will display an exponential distribution of waiting times.","category":"page"},{"location":"randomwalks/#Random-Walk-in-D1","page":"Random walks","title":"Random Walk in D=1","text":"","category":"section"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"using MicrobeAgents\n\nL = 1000\nspace = ContinuousSpace((L,))\ndt = 0.1\nn = 10\nnsteps = 600\n\nmodel = StandardABM(Microbe{1}, space, dt; container=Vector)\nforeach(_ -> add_agent!((0,), model), 1:n)","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"By default, ContinuousSpace will create a periodic domain; this will allow us to mimic an \"infinite\" system. All the microbes have been initialized from position 0, without specifying any further property, so they will be initialized with a random velocity (either (+1,) or (-1,) in this 1D scenario), speed=30.0, and turn_rate=1.0. The motility is set by default to RunTumble(speed=[30.0]) but any other motile pattern in 1D would produce the same result; only speed is relevant here.","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"To run the simulation while collecting the bacterial positions at each step we will then run","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"adata = [position]\nadf, _ = run!(model, nsteps; adata)","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"Since the simulation box is periodic, the trajectories we collected in adf fold around at the box edges. We can unfold them with the unfold! function available through the Analysis submodule. The unfolded coordinates will be stored in a new column :position_unfold. For convenient plotting we can turn this new dataframe column into a matrix with one trajectory per column with adf_to_matrix.","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"Analysis.unfold!(adf, model)\ntrajectories = Analysis.adf_to_matrix(adf, :position_unfold)","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"trajectories is now a Matrix{SVector{1,Float64}}. To obtain the x positions for plotting we can call","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"x = first.(trajectories)\nt = axes(x,1) .* dt\nplot(t,x,lab=false,xlab=\"time\",ylab=\"displacement\")","category":"page"},{"location":"randomwalks/#Random-walks-with-different-motile-patterns-in-D2","page":"Random walks","title":"Random walks with different motile patterns in D=2","text":"","category":"section"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"The procedure to generate a random walk in higher dimensions is exactly the same","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"L = 500\nspace = ContinuousSpace((L,L))\ndt = 0.1\nnsteps = 600\n\nmodel = StandardABM(Microbe{2}, space, dt; container=Vector)","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"But we can now add bacteria with different motility patterns (we import Distributions.jl to use a Normal distribution for the speed of one of our microbes)","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"using Distributions\nadd_agent!(model; motility=RunReverse(speed_forward=[55]), rotational_diffusivity=0.2)\nadd_agent!(model; motility=RunTumble(speed=Normal(30,6)), turn_rate=0.5)\nadd_agent!(model; motility=RunReverseFlick(speed_backward=[6]), rotational_diffusivity=0.1)","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"and then we run and visualize as before","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"adata = [:pos]\nadf, _ = run!(model, nsteps; adata)\n\n# postprocessing\ntraj = MicrobeAgents.unfold(vectorize_adf_measurement(adf,:pos), L)\nx = first.(traj)\ny = last.(traj)\nt = axes(x,1) .* dt\nplot(x, y, xlab=\"x\", ylab=\"y\", ratio=1,\n    lab=[\"RunReverse\" \"RunTumble\" \"RunReverseFlick\"]\n)","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"(Image: Two-dimensional random walks with different motility patterns)","category":"page"},{"location":"examples/Chemotaxis/5_drift_exponential/","page":"Chemotactic drift in exponential ramp with noisy sensing","title":"Chemotactic drift in exponential ramp with noisy sensing","text":"EditURL = \"../../../../examples/Chemotaxis/5_drift_exponential.jl\"","category":"page"},{"location":"examples/Chemotaxis/5_drift_exponential/#Chemotactic-drift-in-exponential-ramp-with-noisy-sensing","page":"Chemotactic drift in exponential ramp with noisy sensing","title":"Chemotactic drift in exponential ramp with noisy sensing","text":"","category":"section"},{"location":"examples/Chemotaxis/5_drift_exponential/","page":"Chemotactic drift in exponential ramp with noisy sensing","title":"Chemotactic drift in exponential ramp with noisy sensing","text":"We will peform simulations of chemotaxis in an exponential concentration ramp using the Brumley model of chemotaxis and measure their drift velocity along the gradient. The concentration field has the form","category":"page"},{"location":"examples/Chemotaxis/5_drift_exponential/","page":"Chemotactic drift in exponential ramp with noisy sensing","title":"Chemotactic drift in exponential ramp with noisy sensing","text":"C(x) = C_0exp(xλ)","category":"page"},{"location":"examples/Chemotaxis/5_drift_exponential/","page":"Chemotactic drift in exponential ramp with noisy sensing","title":"Chemotactic drift in exponential ramp with noisy sensing","text":"and its gradient is","category":"page"},{"location":"examples/Chemotaxis/5_drift_exponential/","page":"Chemotactic drift in exponential ramp with noisy sensing","title":"Chemotactic drift in exponential ramp with noisy sensing","text":"nabla C(x) = dfracC_0lambdaexp(xlambda)hatmathbfx","category":"page"},{"location":"examples/Chemotaxis/5_drift_exponential/","page":"Chemotactic drift in exponential ramp with noisy sensing","title":"Chemotactic drift in exponential ramp with noisy sensing","text":"In the Brumley model, the microbe estimates the local gradient in the form of the convective derivative of the concentration field (Unabla C). The measurement is affected by noise, represented by an intrinsic noise term sigma = sqrt3C(pi a D_c T^3) (Mora & Wingreen (Phys Rev Lett 2010), where a is the microbe radius, T the chemotactic sensory timescale and D_c the thermal diffusivity of the chemoattractant compound) and a pre-factor Pi which represents the \"chemotactic precision\". Higher values of Pi imply higher levels of noise in chemotaxis pathway.","category":"page"},{"location":"examples/Chemotaxis/5_drift_exponential/","page":"Chemotactic drift in exponential ramp with noisy sensing","title":"Chemotactic drift in exponential ramp with noisy sensing","text":"Therefore, with each measurement the bacterium samples from a Normal distribution with mean Unabla C and standard deviation Pisigma. The measurement, mathcalM, determines the evolution of an internal state S which obeys an excitation-relaxation dynamics:","category":"page"},{"location":"examples/Chemotaxis/5_drift_exponential/","page":"Chemotactic drift in exponential ramp with noisy sensing","title":"Chemotactic drift in exponential ramp with noisy sensing","text":"dotS = kappa M -dfracStau_M","category":"page"},{"location":"examples/Chemotaxis/5_drift_exponential/","page":"Chemotactic drift in exponential ramp with noisy sensing","title":"Chemotactic drift in exponential ramp with noisy sensing","text":"This internal state, in turn, determines the tumbling rate.","category":"page"},{"location":"examples/Chemotaxis/5_drift_exponential/","page":"Chemotactic drift in exponential ramp with noisy sensing","title":"Chemotactic drift in exponential ramp with noisy sensing","text":"We will study how Pi affects the drift velocity of bacteria.","category":"page"},{"location":"examples/Chemotaxis/5_drift_exponential/","page":"Chemotactic drift in exponential ramp with noisy sensing","title":"Chemotactic drift in exponential ramp with noisy sensing","text":"using MicrobeAgents\n\nfunction concentration_field(pos, model)\n    x = first(pos)\n    C0 = model.C0\n    λ = model.λ\n    concentration_field(x, C0, λ)\nend\nconcentration_field(x, C0, λ) = C0*exp(x/λ)\n\nfunction concentration_gradient(pos, model)\n    x = first(pos)\n    C0 = model.C0\n    λ = model.λ\n    concentration_gradient(x, C0, λ)\nend\nconcentration_gradient(x, C0, λ) = SVector{3}(i==1 ? C0/λ*exp(x/λ) : 0.0 for i in 1:3)\n\n# wide rectangular channel confined in the z direction\nLx, Ly, Lz = 6000, 3000, 100\nspace = ContinuousSpace((Lx,Ly,Lz); periodic=false)\ndt = 0.1\n\nC0 = 10.0\nλ = Lx/2\nproperties = Dict(\n    :chemoattractant => GenericChemoattractant{3,Float64}(;\n        concentration_field,\n        concentration_gradient\n    ),\n    :C0 => C0,\n    :λ => λ,\n)\nmodel = StandardABM(Brumley{3,4}, space, dt; properties, container=Vector)\n\n# add n bacteria for each value of Π\n# all of them initialized at x = 0\nΠs = [1.0, 2.0, 5.0, 10.0, 25.0]\nn = 200\nfor Π in Πs\n    for i in 1:n\n        pos = SVector{3}(0.0, rand()*Ly, rand()*Lz)\n        motility = RunReverseFlick(0.45, [46.5], 0.45, [46.5])\n        add_agent!(pos, model; chemotactic_precision=Π, motility)\n    end\nend\n\n# also store Π for grouping later\nadata = [position, velocity, :chemotactic_precision]\nnsteps = 2000\nadf, = run!(model, nsteps; adata)\n\n# evaluate drift velocity along x direction\ntarget_direction = SVector(1.0, 0.0, 0.0)\nAnalysis.driftvelocity_direction!(adf, target_direction)\n\n# we now want to first average the drift velocities in each group of Π values\n# and then average each group over time to obtain a mean drift\n# the calculation is much easier to perform with the DataFrames package\nusing DataFrames, StatsBase\ngdf = groupby(adf, :chemotactic_precision)\ndrift_velocities = zeros(1+nsteps, length(Πs))\nfor (i,g) in enumerate(gdf)\n    for h in groupby(g, :id)\n        drift_velocities[:,i] .+= h.drift_direction\n    end\n    drift_velocities[:,i] ./= n\nend\navg_drift = vec(mean(drift_velocities; dims=1))\n\n# we apply a smoothing function to remove some noise for better visualization\nfunction moving_average(y::AbstractVector, m::Integer)\n    @assert isodd(m)\n    out = similar(y)\n    R = CartesianIndices(y)\n    Ifirst, Ilast = first(R), last(R)\n    I1 = m÷2 * oneunit(Ifirst)\n    for I in R\n        n, s = 0, zero(eltype(out))\n        for J in max(Ifirst, I-I1):min(Ilast, I+I1)\n            s += y[J]\n            n += 1\n        end\n        out[I] = s/n\n    end\n    return out\nend\nsmoothing_window = 51\nsmooth_drift_velocities = mapslices(\n    y -> moving_average(y, smoothing_window), drift_velocities;\n    dims = 1\n)\n\nusing Plots\nt = axes(smooth_drift_velocities, 1) .* dt\nplot(layout=(1,2), size=(760,440),\n    plot(t, smooth_drift_velocities, lab=Πs',\n        xlab=\"t (s)\", ylab=\"drift (μm/s)\"\n    ),\n    plot(Πs, avg_drift, lw=4, m=:c, ms=8, lab=false,\n        xlab=\"Π\", ylab=\"avg drift (μm/s)\"\n    )\n)","category":"page"},{"location":"examples/Chemotaxis/5_drift_exponential/","page":"Chemotactic drift in exponential ramp with noisy sensing","title":"Chemotactic drift in exponential ramp with noisy sensing","text":"Increasing Π significantly reduces the ability of bacteria to drift along the gradient.","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"position\ndirection\nspeed\nvelocity\nmotilepattern\nrotational_diffusivity\nradius\nstate","category":"page"},{"location":"api/#Base.position","page":"API","title":"Base.position","text":"position(m::AbstractMicrobe)\n\nReturn the position of the microbe.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.direction","page":"API","title":"MicrobeAgents.direction","text":"direction(m::AbstractMicrobe)\n\nReturn the direction versor of the microbe.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.speed","page":"API","title":"MicrobeAgents.speed","text":"speed(m::AbstractMicrobe)\n\nReturn the speed of the microbe.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.velocity","page":"API","title":"MicrobeAgents.velocity","text":"velocity(m::AbstractMicrobe)\n\nReturn the velocity vector of the microbe (direction times speed).\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.motilepattern","page":"API","title":"MicrobeAgents.motilepattern","text":"motilepattern(m::AbstractMicrobe)\n\nReturn the motile pattern of the microbe.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.rotational_diffusivity","page":"API","title":"MicrobeAgents.rotational_diffusivity","text":"rotational_diffusivity(m::AbstractMicrobe)\n\nReturn the rotational diffusivity of the microbe.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.radius","page":"API","title":"MicrobeAgents.radius","text":"radius(m::AbstractMicrobe)\n\nReturn the radius of the microbe.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.state","page":"API","title":"MicrobeAgents.state","text":"state(m::AbstractMicrobe)\n\nReturn the internal state of the microbe.\n\n\n\n\n\n","category":"function"},{"location":"api/#Utils","page":"API","title":"Utils","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"distance\ndistancevector\nrandom_speed\nrandom_velocity\nAnalysis.adf_to_matrix\nAnalysis.adf_to_vectors\nAnalysis.unfold\nAnalysis.unfold!","category":"page"},{"location":"api/#MicrobeAgents.distance","page":"API","title":"MicrobeAgents.distance","text":"distance(a, b, model)\n\nEvaluate the euclidean distance between a and b respecting the boundary conditions of the model\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.distancevector","page":"API","title":"MicrobeAgents.distancevector","text":"distancevector(a, b, model)\n\nEvaluate the distance vector from a to b respecting the boundary conditions of the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.random_speed","page":"API","title":"MicrobeAgents.random_speed","text":"random_speed(microbe, model)\n\nGenerate a random speed from the motile pattern of microbe.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.random_velocity","page":"API","title":"MicrobeAgents.random_velocity","text":"random_velocity(model)\n\nGenerate a random velocity vector with unit norm respecting the dimensionality of model.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.Analysis.adf_to_matrix","page":"API","title":"MicrobeAgents.Analysis.adf_to_matrix","text":"adf_to_matrix(adf, sym)\n\nCollect quantity sym from the agent dataframe adf and return it in matrix form with dimensions (times, microbes). Requires all microbes to exist from start to end of the simulations  (no removals or insertions).\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.Analysis.adf_to_vectors","page":"API","title":"MicrobeAgents.Analysis.adf_to_vectors","text":"adf_to_vectors(adf, sym)\n\nCollect quantity sym from the agent dataframe adf and return a vector of such quantity for each microbe id.\n\n\n\n\n\n","category":"function"},{"location":"api/#MeanSquaredDisplacement.unfold!","page":"API","title":"MeanSquaredDisplacement.unfold!","text":"unfold!(adf, model; key=:position)\nunfold!(adf, extent; key=:position)\nunfold!(gdf, model; key=:position)\nunfold!(gdf, extent; key=:position)\n\nUnfold the periodic trajectories contained in the agent dataframe adf or in the grouped dataframe gdf where each microbe trajectory was grouped by :id. The second argument can be either the spatial extent of the model, or the model itself from which the extent is automatically extracted.\n\nThe keyword argument key=:position determines what column of the dataframe has to be unfolded.\n\n\n\n\n\n","category":"function"},{"location":"api/#Analysis","page":"API","title":"Data analysis","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Analysis.detect_turns!\nAnalysis.run_durations\nAnalysis.driftvelocity_point!\nAnalysis.driftvelocity_direction!\nmsd\nacf","category":"page"},{"location":"api/#MicrobeAgents.Analysis.detect_turns!","page":"API","title":"MicrobeAgents.Analysis.detect_turns!","text":"detect_turns!(adf; threshold_angle=0.0, kwargs...)\n\nDetect reorientations in the microbe trajectories in adf. Requires adf to have a velocity column. In order to be detected, a reorientation must be larger than the threshold_angle (in radians); the threshold defaults to 0.\n\nA new column is added to the dataframe, with values true when the microbe has turned with respect to the previous frame, or false otherwise.\n\nKeywords\n\nvel_key::Symbol = :velocity: name of the column containing microbe velocities\nnew_key::Symbol = :has_turned: name of the new column storing turn statistics\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.Analysis.run_durations","page":"API","title":"MicrobeAgents.Analysis.run_durations","text":"run_durations(adf; turns_key=:has_turned)\n\nEvaluate the duration (in frames) of all runs detected during a simulation. The dataframe should already contain a column of Bools with values true for frames when a turn has occurred and false otherwise (see detect_turns!). The function returns a vector of run durations for each microbe.\n\nturns_key defines the name of the column where the turn statistics is stored (defaults to :has_turned).\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.Analysis.driftvelocity_point!","page":"API","title":"MicrobeAgents.Analysis.driftvelocity_point!","text":"driftvelocity_point!(adf, target; normalize=false, kwargs...)\ndriftvelocity_point!(gdf, target; normalize=false, kwargs...)\n\nEvaluate the drift velocity of microbes towards a target point, extracting their positions and velocities from the agent dataframe adf or from the grouped dataframe gdf (grouped by :id). Requires the existence of columns containing the position and velocity of microbes. By convention the drift velocity will be positive for motion towards the target point.\n\nKeywords\n\nnormalize = false: whether drift velocities should be normalized by the instantaneous speed of the microbes\npos_key::Symbol = :position: name of the column containing microbe positions\nvel_key::Symbol = :velocity: name of the column containing microbe velocities\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.Analysis.driftvelocity_direction!","page":"API","title":"MicrobeAgents.Analysis.driftvelocity_direction!","text":"driftvelocity_direction!(adf, target; normalize=false, kwargs...)\ndriftvelocity_direction!(gdf, target; normalize=false, kwargs...)\n\nEvaluate the drift velocity of microbes along a target direction, extracting their positions and velocities from the agent dataframe adf or from the grouped dataframe gdf (grouped by :id). Requires the existence of a column containing the velocity of microbes. By convention the drift velocity will be positive for motion along the target directoin.\n\nKeywords\n\nnormalize = false: whether drift velocities should be normalized by the instantaneous speed of the microbes\nvel_key::Symbol = :velocity: name of the column containing microbe velocities\n\n\n\n\n\n","category":"function"},{"location":"examples/Chemotaxis/4_response_functions/","page":"Comparison of chemotactic response functions","title":"Comparison of chemotactic response functions","text":"EditURL = \"../../../../examples/Chemotaxis/4_response_functions.jl\"","category":"page"},{"location":"examples/Chemotaxis/4_response_functions/#Comparison-of-chemotactic-response-functions","page":"Comparison of chemotactic response functions","title":"Comparison of chemotactic response functions","text":"","category":"section"},{"location":"examples/Chemotaxis/4_response_functions/","page":"Comparison of chemotactic response functions","title":"Comparison of chemotactic response functions","text":"Here we will compare the chemotactic response function of the Celani and BrownBerg model to an impulse stimulus of chemoattractant.","category":"page"},{"location":"examples/Chemotaxis/4_response_functions/","page":"Comparison of chemotactic response functions","title":"Comparison of chemotactic response functions","text":"While Celani only needs the concentration_field to determine the chemotactic response, BrownBerg also needs the the time derivative (concentration_ramp) to be defined explicitly (also the concentration_gradient but it's not relevant in this specific study).","category":"page"},{"location":"examples/Chemotaxis/4_response_functions/","page":"Comparison of chemotactic response functions","title":"Comparison of chemotactic response functions","text":"using MicrobeAgents\nusing Plots\n\nθ(a,b) = a>b ? 1.0 : 0.0 # Heaviside theta function\nfunction concentration_field(pos, model)\n    C₀ = model.C₀\n    C₁ = model.C₁\n    t₁ = model.t₁\n    t₂ = model.t₂\n    dt = model.timestep\n    t = abmtime(model) * dt\n    concentration_field(t, C₀, C₁, t₁, t₂)\nend\nconcentration_field(t,C₀,C₁,t₁,t₂) = C₀+C₁*θ(t,t₁)*(1-θ(t,t₂))\n\nδ(t,dt) = 0 <= t <= dt ? 1.0/dt : 0.0 # discrete approximation to Dirac delta\nfunction concentration_ramp(pos, model)\n    C₀ = model.C₀\n    C₁ = model.C₁\n    t₁ = model.t₁\n    t₂ = model.t₂\n    dt = model.timestep\n    t = abmtime(model) * dt\n    concentration_ramp(t, C₀, C₁, t₁, t₂, dt)\nend\nfunction concentration_ramp(t, C₀, C₁, t₁, t₂, dt)\n    C₁*(δ(t-t₁, dt) - δ(t-t₂, dt))\nend\n\nspace = ContinuousSpace(ntuple(_ -> 500.0, 3)) # μm\nC₀ = 1.0 # μM\nC₁ = 2.0-C₀ # μM\nT = 50.0 # s\ndt = 0.1 # s\nt₁ = 10.0 # s\nt₂ = 30.0 # s\nproperties = Dict(\n    :chemoattractant => GenericChemoattractant{3,Float64}(;\n        concentration_field,\n        concentration_ramp\n    ),\n    :C₀ => C₀,\n    :C₁ => C₁,\n    :t₁ => t₁,\n    :t₂ => t₂,\n)\n\nmodel = StandardABM(Union{BrownBerg{3},Celani{3}}, space, dt; properties)\n\nadd_agent!(BrownBerg{3}, model; motility=RunTumble(1.0, [0]),\n    memory=1,\n)\nadd_agent!(Celani{3}, model; motility=RunTumble(1.0, [0]), gain=4)\nadd_agent!(Celani{3}, model; motility=RunTumble(1.0, [0]), gain=4,\n    chemotactic_precision=50.0\n)\n\nnsteps = round(Int, T/dt)\nadata = [bias]\nadf, = run!(model, nsteps; adata)\n\nS = Analysis.adf_to_matrix(adf, :bias)\n\n_pink = palette(:default)[4]\nplot()\nx = (0:dt:T) .- t₁\nplot!(\n    x, S,\n    lw=1.5, lab=[\"BrownBerg\" \"Celani\" \"Celani + Noise\"]\n)\nplot!(ylims=(-0.1,2.1), ylab=\"Response\", xlab=\"time (s)\")\nplot!(twinx(),\n    x, t -> concentration_field(t.+t₁,C₀,C₁,t₁,t₂),\n    ls=:dash, lw=1.5, lc=_pink, lab=false,\n    tickfontcolor=_pink,\n    ylab=\"C (μM)\", guidefontcolor=_pink\n)","category":"page"},{"location":"examples/RandomWalks/3_randomwalk3D/","page":"3D Random walk","title":"3D Random walk","text":"EditURL = \"../../../../examples/RandomWalks/3_randomwalk3D.jl\"","category":"page"},{"location":"examples/RandomWalks/3_randomwalk3D/#3D-Random-walk","page":"3D Random walk","title":"3D Random walk","text":"","category":"section"},{"location":"examples/RandomWalks/3_randomwalk3D/","page":"3D Random walk","title":"3D Random walk","text":"Without any significant difference, we can also simulate three-dimensional random walks.","category":"page"},{"location":"examples/RandomWalks/3_randomwalk3D/","page":"3D Random walk","title":"3D Random walk","text":"using MicrobeAgents\nusing Distributions\nusing Plots\n\nL = 500\nspace = ContinuousSpace((L,L,L))\ndt = 0.1\nmodel = StandardABM(Microbe{3}, space, dt)\n\nadd_agent!(model; motility=RunReverse(1.0, [55], 1.0, [55]), rotational_diffusivity=0.2)\nadd_agent!(model; motility=RunTumble(2.0, Normal(30,6)))\nadd_agent!(model; motility=RunReverseFlick(1.0, [30], 1.0, [6]), rotational_diffusivity=0.1)\n\nnsteps = 600\nadata = [position]\nadf, _ = run!(model, nsteps; adata)\n\nAnalysis.unfold!(adf, model)\ntraj = Analysis.adf_to_matrix(adf, :position_unfold)\nx = first.(traj)\ny = getindex.(traj, 2)\nz = last.(traj)\nt = axes(x,1) .* dt\n\nplot(x, y, z, xlab=\"x\", ylab=\"y\", zlab=\"z\", lw=2, ratio=1,\n    lab=[\"RunReverse\" \"RunTumble\" \"RunReverseFlick\"]\n)","category":"page"},{"location":"examples/RandomWalks/2_randomwalk2D_motilepatterns/","page":"2D Random walk and motile patterns","title":"2D Random walk and motile patterns","text":"EditURL = \"../../../../examples/RandomWalks/2_randomwalk2D_motilepatterns.jl\"","category":"page"},{"location":"examples/RandomWalks/2_randomwalk2D_motilepatterns/#2D-Random-walk-and-motile-patterns","page":"2D Random walk and motile patterns","title":"2D Random walk and motile patterns","text":"","category":"section"},{"location":"examples/RandomWalks/2_randomwalk2D_motilepatterns/","page":"2D Random walk and motile patterns","title":"2D Random walk and motile patterns","text":"Here we will simulate two dimensional random walk with different motile patterns.","category":"page"},{"location":"examples/RandomWalks/2_randomwalk2D_motilepatterns/","page":"2D Random walk and motile patterns","title":"2D Random walk and motile patterns","text":"As usual we start by setting up the model.","category":"page"},{"location":"examples/RandomWalks/2_randomwalk2D_motilepatterns/","page":"2D Random walk and motile patterns","title":"2D Random walk and motile patterns","text":"using MicrobeAgents\nusing Distributions\nusing Plots\n\nL = 500 # space size in μm\nspace = ContinuousSpace((L,L)) # defaults to periodic\ndt = 0.1 # integration timestep in s\nmodel = StandardABM(Microbe{2}, space, dt)","category":"page"},{"location":"examples/RandomWalks/2_randomwalk2D_motilepatterns/","page":"2D Random walk and motile patterns","title":"2D Random walk and motile patterns","text":"We will now add microbes individually, choosing different properties for each. The motile pattern can be customized through the motility keyword.","category":"page"},{"location":"examples/RandomWalks/2_randomwalk2D_motilepatterns/","page":"2D Random walk and motile patterns","title":"2D Random walk and motile patterns","text":"The RunTumble motility consists of straight runs interspersed with isotropic reorientations (tumbles). With the first argument, we set the average duration of tumbles, 1 s in this case. We can then define the speed to follow a a Normal distribution (from Distributions.jl) with mean 30 μm/s and standard deviation 6 μm/s. This means that, after every tumble, the microbe will change its speed following this distribution. Further, we can set tumbles to also have a finite duration, let's say 0.1 s.","category":"page"},{"location":"examples/RandomWalks/2_randomwalk2D_motilepatterns/","page":"2D Random walk and motile patterns","title":"2D Random walk and motile patterns","text":"add_agent!(model; motility=RunTumble(1.0, Normal(30,6), 0.1))","category":"page"},{"location":"examples/RandomWalks/2_randomwalk2D_motilepatterns/","page":"2D Random walk and motile patterns","title":"2D Random walk and motile patterns","text":"The RunReverse motility consists of alternating straight runs and 180-degree reversals. This motility pattern is implemented as a 4-step motility (i.e., Motility{4}): a run \"forward\", a reversal of direction, a run \"backward\", and another reversal of direction, after which the cycle starts again. In principle, each of these 4 steps can be modified independently from the others. Here, we will set the duration and speed of the two run steps, and keep default values for reversals. Further, we set the rotational_diffusivity of the microbe to 0.2 rad²/s; in absence of rotational diffusion, the run reverse motility is pathologically incapable of exploring space efficiently.","category":"page"},{"location":"examples/RandomWalks/2_randomwalk2D_motilepatterns/","page":"2D Random walk and motile patterns","title":"2D Random walk and motile patterns","text":"add_agent!(model; motility=RunReverse(1.0, [30.0], 0.7, [20.0]), rotational_diffusivity=0.2)","category":"page"},{"location":"examples/RandomWalks/2_randomwalk2D_motilepatterns/","page":"2D Random walk and motile patterns","title":"2D Random walk and motile patterns","text":"The RunReverseFlick motility consists of a straight run, a 180-degree reversal, then another straight run followed by a 90-degree reorientation (the flick). Like the RunReverse, this is a four-step motility pattern; indeed, we can imagine it as a RunReverse where the reorientation after the \"backward\" run is 90 instead of 180 degrees. Again, we will set only run durations and speeds. We also set the rotational diffusivity to 0.1 rad²/s.","category":"page"},{"location":"examples/RandomWalks/2_randomwalk2D_motilepatterns/","page":"2D Random walk and motile patterns","title":"2D Random walk and motile patterns","text":"add_agent!(model; motility=RunReverseFlick(2.0, [25.0], 0.5, [25.0]), rotational_diffusivity=0.1)","category":"page"},{"location":"examples/RandomWalks/2_randomwalk2D_motilepatterns/","page":"2D Random walk and motile patterns","title":"2D Random walk and motile patterns","text":"Now we can run (collecting the microbe positions at each timestep), unfold the trajectories, and visualize them.","category":"page"},{"location":"examples/RandomWalks/2_randomwalk2D_motilepatterns/","page":"2D Random walk and motile patterns","title":"2D Random walk and motile patterns","text":"nsteps = 600\nadata = [position]\nadf, _ = run!(model, nsteps; adata)\n\nAnalysis.unfold!(adf, model)\ntraj = Analysis.adf_to_matrix(adf, :position_unfold)\nx = first.(traj)\ny = last.(traj)\nt = axes(x,1) .* dt\n\nplot(x, y, xlab=\"x\", ylab=\"y\", ratio=1,\n    lab=[\"RunTumble\" \"RunReverse\" \"RunReverseFlick\"]\n)","category":"page"},{"location":"examples/Chemotaxis/3_xie_response-function/","page":"Response function (Xie)","title":"Response function (Xie)","text":"EditURL = \"../../../../examples/Chemotaxis/3_xie_response-function.jl\"","category":"page"},{"location":"examples/Chemotaxis/3_xie_response-function/#Response-function-(Xie)","page":"Response function (Xie)","title":"Response function (Xie)","text":"","category":"section"},{"location":"examples/Chemotaxis/3_xie_response-function/","page":"Response function (Xie)","title":"Response function (Xie)","text":"In this example we will probe the response function implemented in the Xie model of chemotaxis. The impulse response function is the \"output\" of the bacterial chemotaxis pathway when presented with an input signal`.","category":"page"},{"location":"examples/Chemotaxis/3_xie_response-function/","page":"Response function (Xie)","title":"Response function (Xie)","text":"To do this, we will emulate another classical laboratory assay, where the bacterium is tethered to a wall, and it is exposed to a temporal change in the concentration of a chemoattractant. The response to the stimulus can be measured by observing modulations in the instantaneous tumbling rate. For each of the implemented microbe types, MicrobeAgents provides a bias function which returns the instantaneous bias in the tumbling rate, evaluated from the internal state of the microbe. Monitoring the time evolution of the tumble bias under teporal stimuli then allows us to access the response function of the microbe.","category":"page"},{"location":"examples/Chemotaxis/3_xie_response-function/","page":"Response function (Xie)","title":"Response function (Xie)","text":"In the Xie model, chemotaxis is implemented by direct samplings of the concentration_field, thus we don't need to explicitly define neither a concentration_gradient nor a concentration_time_derivative. We will represent our temporal stimuli in the form of square waves which instantaneously switch from a baseline value C₀ to a peak value C₁+C₀ homogeneously over space. The excitation will occur at a time t₁ and go back to baseline levels at a time t₂.","category":"page"},{"location":"examples/Chemotaxis/3_xie_response-function/","page":"Response function (Xie)","title":"Response function (Xie)","text":"using MicrobeAgents\nusing Plots\n\nθ(a,b) = a>b ? 1.0 : 0.0 # heaviside theta function\nfunction concentration_field(pos, model)\n    C₀ = model.C₀\n    C₁ = model.C₁\n    t₁ = model.t₁\n    t₂ = model.t₂\n    dt = model.timestep\n    t = abmtime(model) * dt\n    # notice the time dependence!\n    concentration_field(t, C₀, C₁, t₁, t₂)\nend\nconcentration_field(t,C₀,C₁,t₁,t₂) = C₀+C₁*θ(t,t₁)*(1-θ(t,t₂))\n\nspace = ContinuousSpace(ntuple(_ -> 500.0, 3)) # μm\nC₀ = 0.01 # μM\nC₁ = 5.0-C₀ # μM\nT = 50.0 # s\nt₁ = 15.0 # s\nt₂ = 35.0 # s\nproperties = Dict(\n    :chemoattractant => GenericChemoattractant{3,Float64}(; concentration_field),\n    :C₀ => C₀,\n    :C₁ => C₁,\n    :t₁ => t₁,\n    :t₂ => t₂,\n)\n\ndt = 0.1 # s\nmodel = StandardABM(Xie{3,4}, space, dt; properties)","category":"page"},{"location":"examples/Chemotaxis/3_xie_response-function/","page":"Response function (Xie)","title":"Response function (Xie)","text":"A peculiarity of the Xie model is that the chemotactic properties of the microbe differ between the forward and backward motile states, so we can probe the response function in both the forward and backward motile state by initializing two distinct microbes in the two states. To keep the microbes in these motile states for the entire experiment duration, we suppress their tumbles, and (just for total consistency with experiments) we also set their speed to 0.","category":"page"},{"location":"examples/Chemotaxis/3_xie_response-function/","page":"Response function (Xie)","title":"Response function (Xie)","text":"add_agent!(model; motility=RunReverseFlick(Inf, [0], 0.0, [0]))\nadd_agent!(model; motility=RunReverseFlick(0.0, [0], Inf, [0]))\nmodel[2].motility.current_state = 3 # manually set to backward run state","category":"page"},{"location":"examples/Chemotaxis/3_xie_response-function/","page":"Response function (Xie)","title":"Response function (Xie)","text":"In addition to the bias, we will also monitor two other quantities state_m and state_z which are internal variables of the Xie model which represent the methylation and dephosphorylation processes which together control the chemotactic response of the bacterium.","category":"page"},{"location":"examples/Chemotaxis/3_xie_response-function/","page":"Response function (Xie)","title":"Response function (Xie)","text":"nsteps = round(Int, T/dt)\nadata = [bias, :state_m, :state_z]\nadf, = run!(model, nsteps; adata)\n\nS = Analysis.adf_to_matrix(adf, :bias)\nm = (Analysis.adf_to_matrix(adf, :state_m))[:,1] # take only fw\nz = (Analysis.adf_to_matrix(adf, :state_z))[:,1] # take only fw","category":"page"},{"location":"examples/Chemotaxis/3_xie_response-function/","page":"Response function (Xie)","title":"Response function (Xie)","text":"We first look at the response function in the forward and backward motile state: when the concentration increases we have a sharp negative response (the tumble bias decreases), then the bacterium adapts to the new concentration level, and when it drops back to the basal level we observe a sharp positive response (the tumble bisa increases) before adapting again to the new concentration level.","category":"page"},{"location":"examples/Chemotaxis/3_xie_response-function/","page":"Response function (Xie)","title":"Response function (Xie)","text":"_green = palette(:default)[3]\nplot()\nx = (0:dt:T) .- t₁\nplot!(\n    x, S,\n    lw=1.5, lab=[\"Forward\" \"Backward\"]\n)\nplot!(ylims=(-0.1,2.6), ylab=\"Response\", xlab=\"time (s)\")\nplot!(twinx(),\n    x, t -> concentration_field(t.+t₁,C₀,C₁,t₁,t₂),\n    ls=:dash, lw=1.5, lc=_green, lab=false,\n    tickfontcolor=_green,\n    ylab=\"C (μM)\", guidefontcolor=_green\n)","category":"page"},{"location":"examples/Chemotaxis/3_xie_response-function/","page":"Response function (Xie)","title":"Response function (Xie)","text":"By analysing the methylation and dephosphorylation processes, we can understand how the chemotactic response arises. First, when the concentration increases, both m and z increase and converge to a new steady-state value, but since they respond on different timescales, the response (defined by the difference between these two quantities), shows a sharp decrease followed by a slower relaxation. The same occurs for the negative stimulus.","category":"page"},{"location":"examples/Chemotaxis/3_xie_response-function/","page":"Response function (Xie)","title":"Response function (Xie)","text":"x = (0:dt:T) .- t₁\nτ_m = model[1].adaptation_time_m\nτ_z = model[1].adaptation_time_z\nM = m ./ τ_m\nZ = z ./ τ_z\nR = M .- Z\nplot(\n    x, [M Z R],\n    lw=2,\n    lab=[\"m/τ_m\" \"z/τ_z\" \"m/τ_m - z/τ_z\"],\n    xlab=\"time (s)\"\n)","category":"page"},{"location":"examples/Chemotaxis/1_linear_ramp/","page":"Linear concentration ramp","title":"Linear concentration ramp","text":"EditURL = \"../../../../examples/Chemotaxis/1_linear_ramp.jl\"","category":"page"},{"location":"examples/Chemotaxis/1_linear_ramp/#Linear-concentration-ramp","page":"Linear concentration ramp","title":"Linear concentration ramp","text":"","category":"section"},{"location":"examples/Chemotaxis/1_linear_ramp/","page":"Linear concentration ramp","title":"Linear concentration ramp","text":"In this example we will setup an in-silico version of a typical laboratory assay, with chemotactic bacteria moving in a linear concentration ramp, i.e. a concentration field of the form","category":"page"},{"location":"examples/Chemotaxis/1_linear_ramp/","page":"Linear concentration ramp","title":"Linear concentration ramp","text":"C(x) = C_0 + (C_1 - C_0)dfracxL_x qquad x in 0L_x","category":"page"},{"location":"examples/Chemotaxis/1_linear_ramp/","page":"Linear concentration ramp","title":"Linear concentration ramp","text":"We will create a closed two-dimensional domain, mimicking a thin microfluidic chamber, with a length of 3 mm along the x direction, and 1.5 mm along the y direction. We will then setup the concentration field along the x direction and observe chemotactic microbes as they drift towards the high-concentration region of the chamber.","category":"page"},{"location":"examples/Chemotaxis/1_linear_ramp/","page":"Linear concentration ramp","title":"Linear concentration ramp","text":"The first thing we have to do is define two functions for the concentration_field and the concentration_gradient. They must take as arguments the position of a single microbe, and the model (from which we can access other properties of the system). Of course, for our convenience we can dispatch these functions on whatever arguments we want, as long as they have a method whose signature matches the MicrobeAgents API.","category":"page"},{"location":"examples/Chemotaxis/1_linear_ramp/","page":"Linear concentration ramp","title":"Linear concentration ramp","text":"Importantly, the concentration_field must return a scalar, non-negative value. Since the gradient is a vector quantity, the concentration_gradient should instead return an iterable with length equal to the system dimensionality; a SVector is the recommended choice, but NTuples, Vectors, etc.. work just fine.","category":"page"},{"location":"examples/Chemotaxis/1_linear_ramp/","page":"Linear concentration ramp","title":"Linear concentration ramp","text":"All the parameters that we need to evaluate the concentration field and gradient, in our case the two concentration values C₀ and C₁ and the chamber length Lx, should be extracted from the model.","category":"page"},{"location":"examples/Chemotaxis/1_linear_ramp/","page":"Linear concentration ramp","title":"Linear concentration ramp","text":"using MicrobeAgents\nusing Plots\n\n@inline function concentration_field(pos, model)\n    C₀ = model.C₀\n    C₁ = model.C₁\n    Lx = first(spacesize(model))\n    concentration_field(pos,Lx,C₀,C₁)\nend\n@inline concentration_field(pos,Lx,C₀,C₁) = C₀ + (C₁-C₀)*pos[1]/Lx\n\n@inline function concentration_gradient(pos, model)\n    C₀ = model.C₀\n    C₁ = model.C₁\n    Lx = first(spacesize(model))\n    concentration_gradient(pos,Lx,C₀,C₁)\nend\n@inline concentration_gradient(pos,Lx,C₀,C₁) = SVector{length(pos)}(i==1 ? (C₁-C₀)/Lx : 0.0 for i in eachindex(pos))","category":"page"},{"location":"examples/Chemotaxis/1_linear_ramp/","page":"Linear concentration ramp","title":"Linear concentration ramp","text":"Now as usual we define the simulation domain and the integration timestep, but we also define a properties dictionary, which we pass as a keyword argument to StandardABM. This dictionary will contain all the information regarding our concentration field.","category":"page"},{"location":"examples/Chemotaxis/1_linear_ramp/","page":"Linear concentration ramp","title":"Linear concentration ramp","text":"Note that the :C₀ and :C₁ keys have been defined by us; we could have chosen different names for them. The concentration_field and concentration_gradient functions instead must be wrapped into an AbstractChemoattractant type and attached to the :chemoattractant keyword; this is required by MicrobeAgents and assigning these functions to any other key will not produce the desired results. In this example, we define the chemoattractant as a GenericChemoattractant, a default wrapper which takes concentration_field and concentration_gradient as keyword arguments. Notice it also takes the model dimensionality and number type as parameters.","category":"page"},{"location":"examples/Chemotaxis/1_linear_ramp/","page":"Linear concentration ramp","title":"Linear concentration ramp","text":"Finally, to observe chemotaxis, we must use a microbe type for which chemotactic behavior is implemented. If we used the base Microbe, no matter what field we define, we would only observe a random walk since no chemotactic behavior is implemented. The most classic model of chemotaxis is implemented in the BrownBerg type; we will not modify its parameters here and just stick to the default values.","category":"page"},{"location":"examples/Chemotaxis/1_linear_ramp/","page":"Linear concentration ramp","title":"Linear concentration ramp","text":"Lx, Ly = 3000, 1500 # domain size (μm)\nperiodic = false\nspace = ContinuousSpace((Lx,Ly); periodic)\nΔt = 0.05 # timestep (s)\n\n# model setup\nC₀, C₁ = 0.0, 20.0 # μM\nproperties = Dict(\n    :C₀ => C₀,\n    :C₁ => C₁,\n    :chemoattractant => GenericChemoattractant{2,Float64}(;\n        concentration_field, concentration_gradient\n    )\n)\nmodel = StandardABM(BrownBerg{2,2}, space, Δt; properties)\nn = 100 # number of microbes\nfor i in 1:n\n    p0 = spacesize(model) ./ 2\n    delta = rand(abmrng(model), SVector{2}) .* 10\n    pos = p0 .+ delta # random scatter around center\n    motility = RunTumble(0.67, [30.0], 0.1)\n    add_agent!(pos, model; motility)\nend\nmodel","category":"page"},{"location":"examples/Chemotaxis/1_linear_ramp/","page":"Linear concentration ramp","title":"Linear concentration ramp","text":"Now that the model is created, we just run it as usual, collecting the position of the microbes at each timestep. The visualization is slightly more involved since we want to plot the microbe trajectories on top of the concentration field shown as a heatmap, but there is really no difference from what we have seen in the random walk examples.","category":"page"},{"location":"examples/Chemotaxis/1_linear_ramp/","page":"Linear concentration ramp","title":"Linear concentration ramp","text":"In the figure, we will see that all the microbes drift towards the right, where the concentration of the attractant is higher.","category":"page"},{"location":"examples/Chemotaxis/1_linear_ramp/","page":"Linear concentration ramp","title":"Linear concentration ramp","text":"T = 120 # simulation time (s)\nnsteps = round(Int, T/Δt)\nadata = [position]\nadf, mdf = run!(model, nsteps; adata)\n\ntraj = Analysis.adf_to_matrix(adf, :position)\nx = first.(traj)\ny = last.(traj)\n\nts = unique(adf.time) .* Δt\nlw = eachindex(ts) ./ length(ts) .* 3\nxmesh = range(0,Lx,length=100)\nymesh = range(0,Ly,length=100)\nxn = @view x[:,1:15]\nyn = @view y[:,1:15]\nc = concentration_field.(Iterators.product(xmesh,ymesh),Lx,C₀,C₁)\nheatmap(xmesh, ymesh, c', cbar=false, c=:bone,\n    ratio=1, axis=false, grid=false, xlims=(0,Lx), ylims=(0,Ly)\n)\nplot!(xn, yn, lab=false, lw=lw, lc=(1:n)', palette=palette(:thermal,size(xn,2)))\nscatter!(xn[end,:], yn[end,:], lab=false, m=:c, mc=1:n, msw=0.5, ms=8)","category":"page"},{"location":"validation/msd_runtumble/","page":"Mean squared displacement","title":"Mean squared displacement","text":"EditURL = \"../../../examples/Validation/msd_runtumble.jl\"","category":"page"},{"location":"validation/msd_runtumble/#Mean-squared-displacement","page":"Mean squared displacement","title":"Mean squared displacement","text":"","category":"section"},{"location":"validation/msd_runtumble/","page":"Mean squared displacement","title":"Mean squared displacement","text":"The mean squared displacement (MSD) of a population of run-tumble swimmers with an average turn angle theta, should obey, in the absence of rotational diffusion, the following equation (Taktikos et al (PLoS ONE 2012)):","category":"page"},{"location":"validation/msd_runtumble/","page":"Mean squared displacement","title":"Mean squared displacement","text":"textMSD(t) = 2v^2tildetau^2\nleft( dfracttildetau - 1 + exp(-ttildetau) right)","category":"page"},{"location":"validation/msd_runtumble/","page":"Mean squared displacement","title":"Mean squared displacement","text":"where v is the microbe velocity, and tildetau = tau(1-costheta) is the correlation-corrected effective run length.","category":"page"},{"location":"validation/msd_runtumble/","page":"Mean squared displacement","title":"Mean squared displacement","text":"To test this, we will simulate run-tumble motility with different distributions of polar reorientation angles and evaluate their MSDs. For simplicity, since only the average angle matters rather than the entire distribution, we will only allow microbes to perform rotations of angle θ (and -θ for symmetry).","category":"page"},{"location":"validation/msd_runtumble/","page":"Mean squared displacement","title":"Mean squared displacement","text":"using MicrobeAgents\nusing Plots\n\ndt = 0.05 # s\nL = 500.0 # μm\nextent = (L,L,L)\nspace = ContinuousSpace(extent)\n\nθs = [π/6, π/4, π/3, π/2, π]\nα = cos.(θs)\n\nU = 30.0 # μm/s\nτ = 1.0 # s\n\n# we initialize a separate model for each different θ\nmodels = map(_ -> StandardABM(Microbe{3}, space, dt; container=Vector), θs)\nnmicrobes = 100\nfor (i,θ) in enumerate(θs)\n    motility = RunTumble(τ, [U], 0.0, [θ,-θ])\n    foreach(_ -> add_agent!(models[i]; motility), 1:nmicrobes)\nend\n\nnsteps = round(Int, 100τ / dt)\nadata = [position]\nadfs = [run!(model, nsteps; adata)[1] for model in models]\n\nforeach(adf -> Analysis.unfold!(adf, extent), adfs)\nMSD = hcat([Analysis.emsd(adf, :position_unfold)[2:end] for adf in adfs]...)\n\nt = (1:nsteps).*dt\nβ = cos.(θs)\nT = @. τ / (1-β')\ns = t ./ T\nD = @. U^2*T/3\nMSD_theoretical = @. 6D*T * (s - 1 + exp(-s))\nplot(\n    xlab = \"Δt / τ\",\n    ylab = \"MSD / (Uτ)²\",\n    legend = :bottomright, legendtitle = \"1-cosθ\",\n    scale = :log10,\n    yticks = exp10.(-2:2:2),\n    xticks = exp10.(-2:2)\n)\n# show simulation values only at selected lags\nlags = round.(Int, exp10.(range(0, 3, length=20))) |> unique\nscatter!(t[lags]./τ, MSD[lags,:]./(U*τ)^2,\n    m=:x, ms=6, msw=2, lab=false, lc=axes(β,1)'\n)\nplot!(t./τ, MSD_theoretical./(U*τ)^2,\n    lw=2, lab=round.(1 .- β,digits=2)', lc=axes(β,1)'\n)","category":"page"},{"location":"validation/#Validation","page":"Validation","title":"Validation","text":"","category":"section"},{"location":"validation/#Run-Time-Distribution","page":"Validation","title":"Run Time Distribution","text":"","category":"section"},{"location":"validation/","page":"Validation","title":"Validation","text":"(examples/Analysis/run_distribution.jl) Run times should be exponentially distributed, with tau being the inverse of the average turn rate.","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"(Image: Exponential distribution of run times)","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"The smaller the timestep Delta t compared to the average run length tau, the better the agreement between numerical results and theory. A ratio tau  Delta t sim 10 is typically sufficient to have a reasonable agreement.","category":"page"},{"location":"validation/#Velocity-Autocorrelation-Function","page":"Validation","title":"Velocity Autocorrelation Function","text":"","category":"section"},{"location":"validation/","page":"Validation","title":"Validation","text":"Velocity autocorrelation functions for the three motility patterns should obey the following equations (Taktikos et al. PLoS ONE 2012): `` \\phi(t) = \\begin{cases}   \\text{exp}(-t/\\tau), & \\text{run-tumble} \\\n  \\text{exp}(-2t/\\tau), & \\text{run-reverse} \\\n  (1-t/2\\tau)\\text{exp}(-t/\\tau), & \\text{run-reverse-flick} \\end{cases} `` (assuming no rotational diffusion, and that forward and backward mode have identical timescales for the run-reverse-flick swimmer).","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"(Image: Velocity autocorrelation functions for run-tumble, run-reverse, run-reverse-flick)","category":"page"},{"location":"validation/#Mean-Squared-Displacement","page":"Validation","title":"Mean Squared Displacement","text":"","category":"section"},{"location":"validation/","page":"Validation","title":"Validation","text":"The mean squared displacement (MSD) for a run-tumble swimmer with average turn angle theta (and without rotational diffusion) should obey the following equation (Taktikos et al. PLoS ONE 2012):","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"textMSD(t) = 2v^2tildetau^2 (ttildetau - 1 + e^-ttildetau) where tildetau = tau(1-costheta).","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"(Image: MSD of run-tumble motility with varying turn angle distributions)","category":"page"},{"location":"introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"introduction/#Structure","page":"Introduction","title":"Structure","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"An AgentBasedModel object embeds all the properties of the system to be simulated and maps unique IDs to microbe instances. During the simulation, the model is evolved in discrete time steps, with each microbe's position, velocity and \"state\" being updated according to specified rules. Standard rules for motion, reorientations and chemotaxis are available by default, but custom behaviors can be implemented via user-defined functions.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The typical workflow to run a simulation in MicrobeAgents.jl goes as follows:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Define the size and properties of the space in which the microbes will move.\nChoose an appropriate microbe type to represent the desired behavior, or define a new one.\nInitialize an AgentBasedModel object with the desired space, microbe type, integration timestep, and any extra property needed for the simulation.\nPopulate the ABM with microbe instances.\nChoose the observables to collect during production and run the model.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"MicrobeAgents.jl re-exports and extends various function from Agents.jl in order to work as a standalone, but it is generally recommended to use it in combination with Agents.jl for extra goodies.","category":"page"},{"location":"introduction/#Space","page":"Introduction","title":"Space","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"MicrobAgents.jl only supports continuous spaces with dimensions 1, 2 or 3. Spaces can be created with the ContinuousSpace function (reexported from Agents.jl). The extent of the space must be given as a tuple or SVector, and periodicity is set with the periodic kwarg (defaults to true).","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"# one-dimensional periodic space\nextent = (1.0,)\nContinuousSpace(extent)\n\n# two-dimensional non-periodic space\nextent = (1.0, 2.0)\nContinuousSpace(extent; periodic=false)\n\n# three-dimensional space periodic only along the x direction\nextent = (100.0, 20.0, 20.0)\nContinuousSpace(extent; periodic=(true,false,false))","category":"page"},{"location":"introduction/#Microbes","page":"Introduction","title":"Microbes","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Microbes are represented by subtypes of the AbstractMicrobe type, which is in turn a subtype of AbstractAgent from Agents.jl","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"AbstractMicrobe","category":"page"},{"location":"introduction/#MicrobeAgents.AbstractMicrobe","page":"Introduction","title":"MicrobeAgents.AbstractMicrobe","text":"AbstractMicrobe{D} <: AbstractAgent where {D<:Integer}\n\nAll microbe types in MicrobeAgents.jl simulations must be instances of user-defined types that are subtypes of AbstractMicrobe.     YourMicrobeType{D} <: AbstractMicrobe{D} The parameter D defines the dimensionality of the space in which the microbe type lives (1, 2 and 3 are supported).\n\nAll microbe types must have at least the following fields:\n\nid::Int id of the microbe (used internally by Agents.jl)\npos::SVectpr{D,Float64} position of the microbe\nvel::SVector{D,Float64} velocity of the microbe\nmotility::AbstractMotility motile pattern of the microbe\nturn_rate::Real average reorientation rate of the microbe\nrotational_diffusivity::Real coefficient of brownian rotational diffusion\nradius::Real equivalent spherical radius of the microbe\nstate::Real generic variable for a scalar internal state\n\n\n\n\n\n","category":"type"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"MicrobeAgents provides different AbstractMicrobe subtypes representing different models of bacterial behavior from the scientific literature. The list of implemented models can be obtained with subtypes(AbstractMicrobe).","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"A basic type, which is typically sufficient for simple motility simulations and does not include chemotaxis, is the Microbe type.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Microbe","category":"page"},{"location":"introduction/#MicrobeAgents.Microbe","page":"Introduction","title":"MicrobeAgents.Microbe","text":"Microbe{D,N} <: AbstractMicrobe{D,N}\n\nBase microbe type for simple simulations. D is the space dimensionality and N is the number of states of the microbe's motility pattern.\n\nMicrobe has the required fields\n\nid::Int an identifier used internally\npos::SVector{D,Float64} spatial position\nvel::SVector{D,Float64} unit velocity vector\nspeed::Float64 magnitude of the velocity vector\nmotility::Motility{N} motility pattern\n\nand the default parameters\n\nrotational_diffusivity::Float64 = 0.0 coefficient of brownian rotational diffusion\nradius::Float64 = 0.0 equivalent spherical radius of the microbe\nstate::Float64 = 0.0 generic variable for a scalar internal state\n\n\n\n\n\n","category":"type"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Microbe instances should only be created within an AgentBasedModel, the fundamental structure which embeds everything that has to do with the agent-based simulations you want to run. In MicrobeAgents.jl, models are created through the StandardABM function.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"StandardABM","category":"page"},{"location":"introduction/#Agents.StandardABM","page":"Introduction","title":"Agents.StandardABM","text":"StandardABM(MicrobeType, space, timestep; kwargs...)\n\nExtension of the Agents.StandardABM method for microbe types. Implementation of AgentBasedModel where agents can be added and removed at any time. If agents removal is not required, it is recommended to use the keyword argument container = Vector for better performance. See Agents.AgentBasedModel for detailed information on the keyword arguments.\n\nArguments\n\nMicrobeType: subtype of AbstractMicrobe{D}, with explicitly specified dimensionality D. A list of available options can be obtained by running subtypes(AbstractMicrobe).\nspace: a ContinuousSpace{D} with the same dimensionality D as MicrobeType which specifies the spatial properties of the simulation domain.\ntimestep: the integration timestep of the simulation.\n\nKeywords\n\nproperties: additional container of data to specify model-level properties. MicrobeAgents.jl includes a set of default properties (detailed at the end).\nscheduler = Schedulers.fastest\nrng = Random.default_rng()\nwarn = true\n\nDefault properties\n\nWhen a model is created, a default set of properties is included in the model (MicrobeAgents.default_ABM_properties):\n\nDEFAULT_ABM_PROPERTIES = Dict(\n    :chemoattractant => GenericChemoattractant{D,Float64}()\n    :affect! => chemotaxis!\n)\n\nBy including these default properties, we make sure that all the chemotaxis models will work even without extra user intervention. All these properties can be overwritten by simply passing an equivalent key to the properties dictionary when creating the model.\n\n\n\n\n\n","category":"type"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"To initialize a model we must provide the microbe type, the simulation space, and the integration timestep of the simulation. All other parameters are optional. To setup a model for Microbes living in a 1-dimensional space we can therefore run","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"space = ContinuousSpace((100.0,); periodic=false)\ndt = 0.1\nmodel = StandardABM(Microbe{1}, space, dt)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Now, with the add_agent! function we will populate the model with microbes of the specified type (Microbe{1}). The only argument we must always specify for add_agent! is the motility of the microbe, via the motility keyword. An overview of the motility interface is given later; For now we will just use a Run-Tumble motility with an average run duration of 1 second and a constant swimming speed of 20 micron / second. If unspecified, position, direction and speed of the microbe will be assigned randomly; all the other fields will be assigned default values from the constructor (unless specified). To select a position, it can be passed as the first argument to the add_agent! call, and any other bacterial parameter can be defined via keyword arguments. All of the following are valid calls","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"motility = RunTumble(1.0, [20.0])\n# a Microbe with large radius and low tumble rate\nadd_agent!(model; motility, radius=10.0)\n# a Microbe with custom position and high coefficient of rotational diffusion\nadd_agent!((53.2,), model; motility, rotational_diffusivity=0.5)\n# a Microbe initialized with velocity to the right\nadd_agent!(model; motility, vel=(1.0,))","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"All the other subtypes of AbstractMicrobe work in a similar way, although they will have distinct default values and extra fields. When possible, default values are typically assigned following the original implementation in the literature.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"BrownBerg\nBrumley\nCelani\nXie","category":"page"},{"location":"introduction/#MicrobeAgents.BrownBerg","page":"Introduction","title":"MicrobeAgents.BrownBerg","text":"BrownBerg{D} <: AbstractMicrobe{D}\n\nModel of chemotactic E.coli from 'Brown and Berg (1974) PNAS'\n\nDefault parameters:\n\nmotility = RunTumble(0.67, [30.0], 0.1)\nrotational_diffusivity = 0.035 rad²/s coefficient of brownian rotational diffusion\nradius = 0.5 μm equivalent spherical radius of the microbe\nstate = 0.0 corresponds to 'weighted dPb/dt' in the paper\ngain = 660 s\nreceptor_binding_constant = 100 μM\nmemory = 1 s\n\n\n\n\n\n","category":"type"},{"location":"introduction/#MicrobeAgents.Brumley","page":"Introduction","title":"MicrobeAgents.Brumley","text":"Brumley{D} <: AbstractMicrobe{D}\n\nModel of chemotactic bacterium from 'Brumley et al. (2019) PNAS'. The model is optimized for simulation of marine bacteria and accounts for the presence of (gaussian) sensing noise in the chemotactic pathway.\n\nDefault parameters:\n\nmotility = RunReverseFlick(0.45, [46.5], 0.45, [46.5])\nstate = 0.0 → 'S'\nrotational_diffusivity = 0.035 rad²/s\nmemory = 1.3 s → 'τₘ'\ngain_receptor = 50.0 μM⁻¹ → 'κ'\ngain = 50.0 → 'Γ'\nchemotactic_precision = 6.0 → 'Π'\nradius = 0.5 μm → 'a'\n\n\n\n\n\n","category":"type"},{"location":"introduction/#MicrobeAgents.Celani","page":"Introduction","title":"MicrobeAgents.Celani","text":"Celani{D} <: AbstractMicrobe{D}\n\nModel of chemotactic bacterium using the response kernel from 'Celani and Vergassola (2010) PNAS', extracted from experiments on E. coli.\n\nSensing noise (not present in the original model) is customarily introduced through the molecular counting noise formula by Berg and Purcell, and can be tuned through a chemotactic_precision factor inspired by 'Brumley et al. (2019) PNAS' (defaults to 0, i.e. no noise).\n\nDefault parameters:\n\n`motility = RunTumble(0.67, [30.0], 0.1)\nstate = 0\nrotational_diffusivity = 0.26 rad²/s\ngain = 50.0\nmemory = 1 s\nradius = 0.5 μm\n\n\n\n\n\n","category":"type"},{"location":"introduction/#MicrobeAgents.Xie","page":"Introduction","title":"MicrobeAgents.Xie","text":"Xie{D} <: AbstractMicrobe{D}\n\nModel of chemotactic bacterium adapted from 'Xie et al. (2019) Biophys J'. The model is developed based on experimental measurements of the chemotactic response function in the marine bacterium V. alginolyticus. The peculiarity of the model is the presence of distinct parameters for the forward and backward swimming states.\n\nSensing noise (not present in the original model) is customarily introduced through the molecular counting noise formula by Berg and Purcell, and can be tuned through a chemotactic_precision factor inspired by 'Brumley et al. (2019) PNAS' (defaults to 0, i.e. no noise).\n\nDefault parameters:\n\nmotility = RunReverseFlick(speed = [46.5])\nturn_rate_forward = 2.3 Hz\nturn_rate_backward = 1.9 Hz\nstate = 0.0 s\nstate_m = 0.0 s\nstate_z = 0.0 s\nrotational_diffusivity = 0.26 rad²/s\nadaptation_time_m = 1.29 s\nadaptation_time_z = 0.28 s\ngain_forward = 2.7 1/s\ngain_backward = 1.6 1/s\nbinding_affinity = 0.39 μM\nchemotactic_precision = 0.0\nradius = 0.5 μm\n\n\n\n\n\n","category":"type"},{"location":"introduction/#More-about-models","page":"Introduction","title":"More about models","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"MicrobeAgents.jl exploits the AgentBasedModel interface from Agents.jl. While the standard Agents.jl syntax will always work, it is typically more convenient to use the method extensions provided by MicrobeAgents.jl, which also includes some default parameters required by the simulations. If the simulation requires removal/addition of microbes, it is recommended to call StandardABM with the container=Dict keyword argument, otherwise MicrobeAgents.jl defaults to container=Vector which provides better performance.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"In addition to the microbe instances, the model should also wrap all the other information required to perform the simulation.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"MicrobeAgents.jl defines default timestepping functions which are used to evolve the microbes and the model, and are accessible through the microbe_step! and model_step! keywords in StandardABM. By default, the microbe_step! function performs, in order:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"update microbe position according to current velocity\nrandomize the microbe orientation through rotational diffusion (if present)\nupdate internal state of the microbe (e.g. chemotaxis or other user-defined behavior)\nperform reorientation events following Poissonian statistics","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The model_step! function instead defaults to a dummy function which does nothing. Any custom behavior can be implemented by simply modifying these two functions.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Any type of external parameter that should be used during the simulation should be passed to StandardABM through the properties dictionary.","category":"page"},{"location":"introduction/#Running-a-model","page":"Introduction","title":"Running a model","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"After the model has been created and populated with the desired number of microbes, we are ready to run the simulation. We just need to specify how many steps we want to simulate and what data to collect during the run:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"nsteps = 100\nadf, mdf = run!(model, nsteps; adata=[position])","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"run! will return two dataframes, one for the agent-level data (adf) and one for the model-level data (mdf, which in this case will be empty). This way, we have produced our first random walk. Since adf.position is a vector of static vectors, we first have to unpack the x and y values and then we are ready to plot our trajectory.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"using Plots\nx = first.(adf.position)\ny = last.(adf.position)\nplot(x, y)","category":"page"},{"location":"introduction/#Motility-patterns","page":"Introduction","title":"Motility patterns","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"In MicrobeAgents.jl, motility patterns are represented through the Motility{N} type. A Motility is composed of N instances of MotileState and of a set of transition probabilities between these N states. A MotileState contains information about the speed distribution, turn angle distributions, and average lifetime of a particular state of motion.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"There are two kinds of MotileStates, RunState and TurnState. A RunState is used to represent states associated with translational motion and no angular reorientation (e.g. Run). A TurnState is instead used to represent states where no translational motion happens, but where reorientations may occur (e.g. Tumble, Reverse, Flick, Stop).","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Instances of MotileStates can be arbitrarily combined into a Motility.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Motility","category":"page"},{"location":"introduction/#MicrobeAgents.Motility","page":"Introduction","title":"MicrobeAgents.Motility","text":"Motility(motile_states::NTuple{N,MotileState}, rates...)\n\nConstruct a Motility from a sequence of MotileStates and their transition rates.\n\nmotile_states must be a tuple of MotileState instances. rates must be specified in the form (i => j, p) where i is the index of the starting state (as ordered in the motile_states tuple), j is the index of the state towards which the transition occurs, and p is the probability that, after the duration of i is over, the transition occurs towards the state j. It is not necessary to indicate impossible transitions; any pair i => j which is not explicitly specified is assumed to have a transition probability p=0.\n\nFor example, if we want to define a 3-state motility, composed by a slow but long run, a tumble, and a fast but short run, where the two runs can only transition towards the tumble, but the tumble can transition with probability 30% towards the slow run and 70% towards the fast run, we will call:\n\nMotility((Run(10.0, 2.0), Tumble(), Run(60.0, 0.5)),\n    (1 => 2, 1.0),\n    (2 => 1, 0.3), (2 => 3, 0.7),\n    (3 => 2, 1.0)\n)\n\nSome default constructors for common motility patterns are provided: RunTumble, RunReverse, RunReverseFlick, RunStop\n\n\n\n\n\n","category":"type"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The most common motility patterns are, however, pre-implemented.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"RunTumble\nRunReverse\nRunReverseFlick\nRunStop","category":"page"},{"location":"#MicrobeAgents.jl","page":"Home","title":"MicrobeAgents.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MicrobeAgents.jl is a Julia framework for agent-based simulations of bacterial motility and chemotaxis, built on the amazing Agents.jl.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Runs in 1, 2 and 3 spatial dimensions.\nProvides base motility patterns (Run-Tumble, Run-Reverse, Run-Reverse-Flick, Run-Stop), all with customizable speed and turn angle distributions, and allows user definition of new arbitrary patterns.\nIncludes various models of bacterial chemotaxis (Brown & Berg, PNAS 1974; Celani & Vergassola, PNAS 2010; Xie et al, Biophys J 2014; Brumley et al, PNAS 2019).\nFast analysis routines for common quantities of interest (MSD, autocorrelation functions, drift velocity).","category":"page"},{"location":"#Limitations-(some-may-be-temporary,-others-may-be-not)","page":"Home","title":"Limitations (some may be temporary, others may be not)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Only continuous space models are supported\nIntegration timestep also sets the sensory integration timescale in chemotactic models.","category":"page"},{"location":"#What-this-package-is-not-good-for","page":"Home","title":"What this package is not good for","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Although, in principle, you can add arbitrary layers of complexity on top the provided interface, there are a few things for which this package is not a recommended choice and dedicated tools should be used instead:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Hydrodynamic interactions.\nAtomistic representation of biochemical pathways.","category":"page"},{"location":"#Contribute","page":"Home","title":"Contribute","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is still in an early stage of intense development. If you would like to have support for your favorite model of chemotaxis, or need some specific features to be implemented, please open an issue. I'll try to satisfy as many requests as possible.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you would like to take a more active part in the development, please consider contacting me directly at rfoffi@ethz.ch.","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use this package in work that leads to a publication, please cite the GitHub repository:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{Foffi2023,\n    author = {Foffi, R.},\n    title = {MicrobeAgents.jl},\n    year = {2023},\n    publisher = {GitHub},\n    journal = {GitHub repository},\n    howpublished = {\\url{https://github.com/mastrof/MicrobeAgents.jl}}\n}","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project has received funding from the European Union's Horizon 2020 research and innovation programme under the Marie Skłodowska-Curie grant agreement No 955910.","category":"page"}]
}
